# **计算机组成与体系结构实验报告**


- **实验名称：Lab2 32位RISC-V单周期CPU设计**


 
## **一、实验目的**
- 完成一个能够实现指定 RISC-V 指令功能的单周期 CPU 的电路设计


## **二、实验要求**
1. 阅读相关文献资料，理解并掌握 RISC-V 单周期 CPU 的基本构造和功能原理。
2. 编写 Verilog 代码，设计各个 CPU 部件，实现规定的功能。部件资源包括：X0-X31共32通用寄存器、特殊寄存器 PC、256bytes 的 program memory 和 data memory 等。
3. 通过功能仿真对每条指令进行仿真，显示涉及到的寄存器或存储器的值，检验设计的正确性。
<br>
    本设计实现了 RISC-V 架构中常见的12条基本指令，包括：
- 算术运算指令：加法 add、减法 sub、立即数加法 addi、有符号比较 slt、立即数有符号比较 slti
- 逻辑运算指令：按位或 or、立即数按位或 ori
- 存储操作（数据传送）指令：存储字 sw、加载字 lw、加载高位立即数 lui
- 控制转移指令：分支 beq、跳转并链接 jal

## **三、实验原理**
1. RISC-V 单周期 CPU 是一种基于精简指令集（RISC）的处理器。
- 一个单周期CPU中，每条指令的执行需要**一个时钟周期**，只有**一条指令执行完后才能执行下一条指令**，由于每个时钟周期的时间长短相同，因此在确定时钟周期的时间长度时，要以指令集中最复杂的指令需执行的时间为第一考虑。
- 单周期 CPU **使用 PC 作为地址从程序存储器中获得指令**，根据指令的意义完成相应操作，在时钟上升沿将结果写入寄存器，与此同时，PC 也一并被更新。
- RISC-V 有 X0 ~ X31 共**32个通用寄存器**，统称寄存器堆；**寄存器X0的内容总是0**。
- 共**6种指令格式**：R（register）型：寄存器操作数指令；I（immediate）型：短立即数操作或者取数指令； S（store）型：存数指令；B（branch）型：条件跳转指令；J型：无条件跳转；U型：长立即数操作指令。
   
2. 本实验设计了一个支持基本算术、逻辑、存储和分支指令的32位 RISC-V CPU，关键模块包括：
- 顶层模块（top）：集成CPU组件，连接各模块；
- PC 寄存器（PC_reg）：存储下一条指令地址；
- 指令存储器（IM）：存储机器指令，按 PC 值读取指令；
- 寄存器堆（register）：包含32个32位寄存器，支持读写；
- 控制单元（control）：解析指令，生成寄存器写使能、ALU操作类型等控制信号；
- ALU 控制单元（alu_control）：生成 ALU 运算类型；
- ALU（alu）：执行算术逻辑运算，输出结果和零标志；
- 立即数生成器（immgen）：从指令中提取并扩展立即数；
- 数据存储器（DM）：存储数据，支持加载、存储操作；
- 多路选择器（mux）：数据通路中的信号选择（ALU输入、寄存器写入数据等）。

3. 指令执行路程：
- 取指：PC 寄存器输出当前指令地址至 IM；IM 返回32位指令，PC 更新为 PC + 4 或分支目标地址；
- 译码：控制单元解析指令，生成 RegWrite、ALUSrc、MemWrite 等信号；寄存器堆读取 rs1 和 rs2 的数据，立即数生成器根据指令类型扩展立即数；
- 执行：ALU 根据 ALUctr 信号执行运算；
- 访存：对于 lw/sw, DM 根据 ALU 计算的地址读写数据；
- 写回：ALU 结果或 DM 读取的数据通过多路选择器写回寄存器堆。
  

## **四、实验过程（模块设计与实现）**
### **1. top 模块**
#### 功能：顶层模块，集成所有CPU组件并连接各模块间的信号线

#### 输入输出端口
- 输入：
  - clk：时钟信号
  - rst：复位信号

#### 实现思路
1. 将复位信号反相为低电平有效(rst_n)；
2. 实例化所有子模块（PC、寄存器、ALU等）；
3. 通过 wire 类型信号连接各模块；
4. 处理特殊信号：
   - 指令/数据存储器使能信号
   - 多路选择器控制信号
5. 主要数据通路：
   PC→指令存储器→控制单元→寄存器→ALU→数据存储器→写回；

### **2. PC_reg 模块**
#### 功能：程序计数器，实现指令地址的顺序和跳转控制
PC_reg模块是一个程序计数器 (Program Counter) 寄存器的实现，用于在处理器中跟踪当前执行指令的地址。它是处理器控制流的核心组件之一，负责指令的顺序执行和条件跳转。

#### 输入输出端口
- 输入：
  - clk：时钟信号
  - rst_n：复位（低电平有效）
  - imm：跳转偏移量
  - branch：分支指令标志
  - ALU_zero：ALU零标志
  - jal：JAL指令标志
- 输出：
  - PCout：当前的PC值

#### 实现思路
1. PC寄存器存储当前指令地址，输出PCout为组合逻辑，反映内部PC寄存器的值；
2. 采用异步复位，rst_n 为低电平时清零 PC，不依赖时钟；复位优先级最高，覆盖其他所有操作；
3. 每个时钟上升沿：
   - jal=1 时：PC ← PC + 偏移量
   - branch=1 且 ALU_zero=1时：PC ← PC + 偏移量，执行分支跳转
   - 默认情况：PC ← PC + 4，顺序执行
4. 异步输出当前的PC值；


### **3. IM 模块**
#### 功能：指令存储器，存储并输出32位指令
IM 模块是一个指令存储器（Instruction Memory）的实现，用于存储处理器执行的机器指令。它是一个只读存储器（ROM），根据输入的地址输出对应的32位指令。

#### 输入输出端口
- 输入：
  - ce：片选信号
  - addr：32位地址
- 输出：
  - inst：32位指令

#### 实现思路
1. 创建64个32位存储器数组,256字节；
2. 通过 initial 块初始化存储器内容，即由汇编码转化得到的用十六进制表示的机器指令；
3. 地址处理：
   - 取 addr[7:2] 作为字地址（右移2位）
   - 地址越界，片选信号无效（高电平）时输出全0，有效（低电平）时输出对应地址的指令；
4. 用组合逻辑实现异步读取指令，根据输入的32位地址输出对应的32位指令；


### **4. register 模块**

#### 功能：32个32位寄存器组，支持同步写、异步读
register 模块是一个寄存器堆（Register File）的实现，用于在处理器中存储和提供运算所需的操作数。它是处理器数据通路的核心组件之一，负责数据的快速存取和传递。

#### 输入输出端口
- 输入：
  - clk：时钟
  - rst_n：复位
  - regwrite：写使能
  - write_register：写寄存器编号
  - write_data：写数据
  - read_register1/2：读寄存器编号
- 输出：
  - read_data1/2：读数据

#### 实现思路
1. 使用32个32位寄存器组成的数组（register[0:31]）；
2. 采用异步复位，rst_n为低电平时清零所有寄存器，不依赖时钟；复位优先级最高；
3. 写操作：
   - 时钟上升沿触发，当 regwrite 为 1 时将 write_data 写入write_register 指定的寄存器（同步操作）
   - x0 寄存器恒为0（不可写）
4. 读操作：
   - 两个读端口采用组合逻辑实现异步读取
   - x0 寄存器恒返回0
  
### **5. control 模块**
control模块是处理器的控制单元实现，负责根据输入的指令操作码生成各种控制信号。它是处理器指令执行流程的核心控制器，协调数据通路各部件的工作。

#### 功能：主控制单元，解析指令生成控制信号

#### 输入输出端口
- 输入：
  - instruction[6:0]：指令操作码
- 输出：
  - branch/jal：跳转控制
  - memread/write：存储器控制
  - memtoreg：写回选择
  - ALUop：ALU操作类型
  - ALUsrc：ALU输入选择
  - regwrite：寄存器写使能

#### 实现思路
1. 根据 RISC-V 指令操作码解码识别指令类型；
2. 为每类指令生成对应控制信号，控制处理器各部件的操作：
   - R-type：寄存器运算
   - I-type：立即数运算
   - Load/Store：存储器访问
   - Branch：条件跳转
   - JAL：跳转链接
   - LUI：高位立即数
3. 支持RISC-V基础指令集中的R-type、I-type、Load/Store、Branch、LUI和JAL指令；
4. 采用组合逻辑，指令变化时立即更新控制信号，默认情况输出全0；

### **6. alu_control 模块**

#### 功能：ALU 操作译码器，生成具体运算控制信号
 alu_control模块是处理器的ALU控制单元实现，负责根据指令类型和ALU操作码生成具体的ALU控制信号。作为控制单元和执行单元间的桥梁，将高层指令转换为底层ALU操作。

#### 输入输出端口
- 输入：
  - ALUop：ALU操作类型
  - instruction：完整指令
- 输出：
  - control_signal：4位 ALU 控制信号

#### 实现思路
1. 结合 ALUop 输入确定指令类别：
   - 00：LUI/JAL
   - 01：分支比较
   - 10：I-type
   - 11：R-type
2. 结合 funct3/funct7 字段确定具体运算（ ADD / SUB / OR / SLT 等）；
3. 输出4位对应的ALU控制信号，可支持16种不同的ALU操作；
4. 组合逻辑实现：输入变化时立即更新控制信号；

### **7. alu 模块**

#### 功能：算术逻辑单元，执行算术逻辑运算（12条RISC-V指令）
ALU算术逻辑单元模块是处理器的核心执行单元，负责执行各种算术和逻辑运算。它根据控制信号对输入的操作数进行计算，并输出结果和状态标志。

#### 输入输出端口
- 输入：
  - control_signal：ALU操作控制信号
  - read_data1/2：寄存器数据（运算数）
  - immediate：符号扩展后的立即数
  - ALU_src：输入选择信号
- 输出：
  - ALU_result：ALU 运算结果
  - ALU_zero：零标志，用于分支判断

#### 实现思路
1. 根据 ALU_src 选择第二操作数（寄存器/立即数）；
2. 支持12种RISC-V基础指令的运算；
3. 生成零标志，为分支指令提供结果是否为0；
4. 组合逻辑实现：输入变化时立即更新输出；

### **8. immgen 模块**

#### 功能：立即数的生成与符号扩展
immgen模块是处理器的立即数生成单元，负责根据不同的指令类型从32位指令中提取并符号扩展立即数。它是处理器指令译码阶段的关键组件，为ALU和其他功能单元提供正确的立即数操作数。

#### 输入输出端口
- 输入：
  - instruct：32位指令
- 输出：
  - immediate：扩展后的立即数

#### 实现思路
1. 根据指令类型识别立即数格式：
   - I-type：[31:20]（12位）,符号扩展将12位立即数扩展为32位
   - S-type：[31:25]和[11:7],组合为12位立即数并符号扩展
   - B-type：[31], [7], [30:25], [11:8]（13位，最低位为0）
   - J-type：[31], [19:12], [20], [30:21]（21位，最低位为0）
   - U-type：[31:12]（20位立即数），左移12位低位补0
2. 对提取的立即数进行符号扩展，生成32位标准格式；
3. 组合逻辑实现：指令变化时立即更新输出；

### **9. DM 模块**

#### 功能：数据存储器，支持字节寻址的读写操作
数据存储器模块用于存储和读取程序运行时的数据。它支持字节寻址的读写操作，采用小端序存储格式，是处理器存储子系统的重要组成部分。

#### 输入输出端口
- 输入：
  - clk：时钟信号
  - ce：片选信号
  - we：写使能信号
  - addr：32位地址输入
  - data_i：32位写入数据
- 输出：
  - data_o：32位读取数据

#### 实现思路
1. 256个8位存储器数组（小端序）；
2. 写操作：时钟同步，按字节写入；
3. 读操作：异步读取，组合4字节为32位字；
4. 地址检查防止越界； 


### **10. mux 模块**

#### 功能：写回数据选择，根据控制信号选择正确的数据写回寄存器
多路选择器模块是处理器的写回数据选择单元，负责根据控制信号从多个数据源中选择正确的数据写回寄存器。它是处理器数据通路的关键组件，实现了结果回写的灵活选择机制。

#### 输入输出端口
- 输入：
  - memtoreg：写回数据选择控制信号
  - jal：跳转并链接控制信号
  - out1：输入存储器读取的数据
  - out2：输入ALU运算结果
  - out3：输入PC+4值
  - instruct：指令输入
- 输出：
  - writedata：写回数据

#### 实现思路
1. JAL指令具有最高优先级，覆盖memtoreg信号；
2. 四种数据源选择：
   - jal：PC+4
   - memtoreg=01：存储器数据
   - memtoreg=11：LUI立即数
   - 默认：ALU结果
3. 将10位 PC+4 值零扩展为32位；
4. 支持LUI指令的立即数生成（高20位+低12位0）；
5. 组合逻辑实现：输入变化时立即更新输出；


## **五、实验结果（代码仿真）**
#### 1. 指令：lui x5, 0x00000  ( PC = 0 )
**机器码**：0x000002b7<br>
**功能**：将 0x00000 左移12位(即 0x00000000)加载到寄存器 x5 的高20位，低12位置0<br>
**操作**: x5 = 0x00000 << 12 = 0x00000000
- 执行前:
  - x5 = 0x00000000
  - PC = 0x00000000
- 执行后:
  - x5 = 0x00000000
  - PC = 0x00000004

<img src="image-6.png"  width="50%" height="auto">



#### 2. 指令：addi x5, x5, 0x05  ( PC = 4 )
**机器码**：0x00528293<br>
**功能**：将立即数 0x05 加到寄存器 x5 的当前值（0x00000），结果存回 x5<br>
**操作**：x5 = x5 + 5 = 0 + 5 = 5
- 执行前:
  - x5 = 0x00000000
  - PC = 0x00000004
- 执行后:
  - x5 = 0x00000005
  - PC = 0x00000008

<img src="image-5.png"  width="50%" height="auto">


#### 3. 指令：slti x6, x5, 0x5  ( PC = 8 )
**机器码**：0x0052a313<br>
**功能**：比较 x5 和 5，如果 x5 < 5，则 x6 = 1，否则 x6 = 0<br>
**操作**：比较5 < 5 → 不成立 → x6 = 0
- 执行前:
  - x5 = 0x00000005
  - x6 = 0x00000000
  - PC = 0x00000008
- 执行后:
  - x6 = 0x00000000
  - PC = 0x0000000C
  
 <img src="image-4.png"  width="50%" height="auto"> 

#### 4.指令：addi x10, x0, 25  ( PC = 12 )
**机器码**：0x01900513<br>
**功能**：将 x0 (总是0) 加25，结果存入 x10<br>
**操作**：x10 = 0 + 25 = 25

- 执行前:
  - x0 = 0x00000000
  - x10 = 0x00000000
  - PC = 0x0000000C
- 执行后:
  - x10 = 0x00000019
  - PC = 0x00000010

<img src="image-7.png"  width="50%" height="auto">


#### 5.指令：beq x6, x0, test1  ( PC = 16 )
**机器码**：0x00030463<br>
**功能**：如果 x6 == x0，则跳转到 PC + 8 (test1标签处)<br>
**操作**：x6(0) == x0(0) → 跳转到 PC + 8 = 0x18 (指令6)
- 执行前:
  - x6 = 0x00000000
  - x0 = 0x00000000
  - PC = 0x00000010
- 执行后:
  - PC = 0x00000018 (跳过下一条指令)

<img src="image-8.png"  width="50%" height="auto">


#### 6.指令：jal x0,end  ( PC = 20 )
**机器码**：0x03c0006f<br>
**功能**：无条件跳转到 end 标签处 (PC + 0x3c) ，这条指令被跳过<br>
**操作**：未执行


#### 7.指令：ori x6, x0, 0x5c  ( PC = 24 )
**机器码**：0x05c06313<br>
**功能**：将 x0(0) 与 0x5c 按位或，结果存入x6<br>
**操作**：x6 = 0 | 0x5c = 0x5c
- 执行前:
  - x0 = 0x00000000
  - x6 = 0x00000000
  - PC = 0x00000018
- 执行后:
  - x6 = 0x0000005C
  - PC = 0x0000001C

<img src="image-9.png"  width="50%" height="auto">


#### 8.指令：or x7, x6, x10  ( PC = 28 )
**机器码**：0x00a363b3<br>
**功能**：将 x6 和 x10 按位或，结果存入 x7<br>
**操作**：x7 = 0x5c | 0x19 = 0x5d

- 执行前:
  - x6 = 0x0000005C
  - x10 = 0x00000019
  - x7 = 0x00000000
  - PC = 0x0000001C
- 执行后:
  - x7 = 0x0000005D
  - PC = 0x00000020

<img src="image-10.png"  width="50%" height="auto">

  
#### 9.指令：sub x8, x7, x6  ( PC = 32 )
**机器码**：0x40638433<br>
**功能**：从 x7 中减去 x6，结果存入 x8<br>
**操作**：x8 = 0x5d - 0x5c = 1

- 执行前:
  - x7 = 0x0000005D
  - x6 = 0x0000005C
  - x8 = 0x00000000
  - PC = 0x00000020
- 执行后:
  - x8 = 0x00000001
  - PC = 0x00000024

<img src="image-11.png"  width="50%" height="auto">


#### 10.指令：slt x9, x0, x8  ( PC = 36 )
**机器码**：0x008024b3<br>
**功能**：如果 x0 < x8，则 x9 = 1，否则 x9 = 0<br>
**操作**：0 < 1 → 成立 → x9 = 1
- 执行前:
  - x0 = 0x00000000
  - x8 = 0x00000001
  - x9 = 0x00000000
  - PC = 0x00000024
- 执行后:
  - x9 = 0x00000001
  - PC = 0x00000028

<img src="image-12.png"  width="50%" height="auto">



#### 11.指令：addi x10, x10, 25  ( PC = 40 )
**机器码**：0x01950513<br>
**功能**：将 x10 加 25，结果存入 x10<br>
**操作**：x10 = 25 + 25 = 50    

- 执行前:
  - x10 = 0x00000019
  - PC = 0x00000028
- 执行后:
  - x10 = 0x00000032
  - PC = 0x0000002C

<img src="image-14.png"  width="50%" height="auto">


#### 12.指令：beq x9, x0, test0  ( PC = 44 )
**机器码**：0xfe0484e3<br>
**功能**：如果 x9 == x0，则跳转到 test0 (PC - 24)<br>
**操作**： x9(1) != x0(0) → 不跳转，继续执行下一条
- 执行前:
  - x9 = 0x00000001
  - x0 = 0x00000000
  - PC = 0x0000002C
- 执行后:
  - PC = 0x00000030

<img src="image-15.png"  width="50%" height="auto">


#### 13.指令：addi x6,x0,50  ( PC = 48 )
**机器码**：0x03200313<br>
**功能**：将 x0(0) 加 50，结果存入 x6<br>
**操作**： x6 = 0 + 50 = 50
- 执行前:
  - x0 = 0x00000000
  - x6 = 0x0000005C
  - PC = 0x00000030
- 执行后:
  - x6 = 0x00000032
  - PC = 0x00000034
  
<img src="image-16.png"  width="50%" height="auto">



#### 14.指令：add x9,x10,x6  ( PC = 52 )
**机器码**：0x006504b3<br>
**功能**：将 x10 和 x6 相加，结果存入 x9<br>
**操作**： x9 = 50 + 50 = 100
- 执行前:
  - x10 = 0x00000032
  - x6 = 0x00000032
  - x9 = 0x00000001
  - PC = 0x00000034
- 执行后:
  - x9 = 0x00000064
  - PC = 0x00000038

<img src="image-17.png"  width="50%" height="auto">



#### 15.指令：addi x5, x5, 3  ( PC = 56 )
**机器码**：0x00328293<br>
**功能**：将 x5 加3，结果存入 x5<br>
**操作**：x5 = 5 + 3 = 8

- 执行前:
  - x5 = 0x00000005
  - PC = 0x00000038
- 执行后:
  - x5 = 0x00000008
  - PC = 0x0000003C

<img src="image-18.png"  width="50%" height="auto">



#### 16.指令：sw x9,0(x5)  ( PC = 60 )
**机器码**：0x0092a023<br>
**功能**：将 x9 的值存储到内存地址 x5 + 0 处<br>
**操作**：mem[8] = 100
- 执行前:
  - x5 = 0x00000008
  - x9 = 0x00000064
  - mem[8] = 0x00000000
  - PC = 0x0000003C
- 执行后:
  - mem[8] = 0x00000064
  - PC = 0x00000040

<img src="image-19.png"  width="50%" height="auto">

#### 17.指令：addi x6,x0,4  ( PC = 64 )
**机器码**：0x00400313<br>
**功能**：将 x0(0) 加4，结果存入 x6<br>
**操作**：x6 = 0 + 4 = 4
- 执行前:
  - x0 = 0x00000000
  - x6 = 0x00000032
  - PC = 0x00000040
- 执行后:
  - x6 = 0x00000004
  - PC = 0x00000044

<img src="image-20.png"  width="50%" height="auto">

#### 18.指令：sub x5,x5,x6  ( PC = 68 )
**机器码**：0x406282b3<br>
**功能**：从 x5 中减去 x6，结果存入 x5<br>
**操作**：x5 = 8 - 4 = 4
- 执行前:
  - x5 = 0x00000008
  - x6 = 0x00000004
  - PC = 0x00000044
- 执行后:
  - x5 = 0x00000004
  - PC = 0x00000048

<img src="image-21.png"  width="50%" height="auto">


#### 19.指令：lw x10,4(x5)  ( PC = 72 )
**机器码**：0x0042a503<br>
**功能**：从内存地址 x5 + 4 处加载值到 x10<br>
**操作**：x10 = mem[4+4] = mem[8] = 100
- 执行前:
  - x5 = 0x00000004
  - x10 = 0x00000032
  - mem[8] = 0x00000064
  - PC = 0x00000048
- 执行后:
  - x10 = 0x00000064
  - PC = 0x0000004C

<img src="image-22.png"  width="50%" height="auto">


#### 20.指令：beq x0,x0,test0  ( PC = 76 )
**机器码**：0xfc0004e3<br>
**功能**：x0与x0相等时（恒成立），无条件跳转到 test0 (PC - 24)<br>
**操作**：跳转到 PC - 24 = 0x34 （指令14）
- 执行前:
  - x0 = 0x00000000
  - PC = 0x0000004C
- 执行后:
  - PC = 0x00000034

<img src="image-23.png"  width="50%" height="auto">

- 跳转到 PC = 0x34 后，指令为 add x9, x10, x6，因此 x9 = 0x64 + 0x04 = 0x68， 由于 x10 和 x6 的值固定，后续指令会重复执行但寄存器值不再变化。


#### 21.指令：jal x0,end  ( PC = 80 )
**机器码**：0x0000006f<br>
**功能**：跳转到当前位置加偏移量为0的位置，形成无限循环<br>
**操作**：跳转到自身，PC不发生改变，寄存器值不再变化

<img src="image-24.png"  width="50%" height="auto">

#### X5-X10的最终结果：
- x5: 0x00000004
- x6: 0x00000004
- x7: 0x0000005D
- x8: 0x00000001
- x9: 0x00000068
- x10: 0x00000064

## **六、实验思考**
### **1. 遇到的问题及解决方法**
1. **问题描述**：由于之前没有任何计算机系统基础的知识，仅靠课堂知识难以清楚学会一个单周期cpu如何从零开始上手写起。<br>**解决方法**：上网查找各类资料和视频进行学习，逐步清楚了每个模块的作用和整个cpu的架构方式，遇到问题时询问同学或借助AI工具进行理解。
   
2. **问题描述**：对如何仿真不熟悉，不清楚如何实现功能仿真，误以为在行为仿真界面下没有显示是设计代码中的结构问题。<br>**解决方法**：在b站上搜索视频发现可以用在行为仿真中通过拖拽添加变量名的方式，将所需显示的所有变量放入仿真界面再点击运行后即可显示完整的全部仿真结果。
   
3. **问题描述**：在指令存储器 IM 中初始化指令存储器内容时，将每条汇编转成的机器指令放入代码中很麻烦，需要一条条添加入 inst_memory 数组。<br>**解决方法**：通过与同学交流了解到可以使用外部的.mem文件对存储器内容进行初始化。具体方式为：创建一个 instructions.mem 的文本文件，将原来initial块中所有指令都放入该文本文件中，将initial块改为下述语句。为了保证提交项目代码的完整性，在提交文件中没有做这个修改。
    ```verilog
    initial begin
        $readmemh("instructions.mem", inst_memory);
    end 
    ```
   
4. **问题描述**：在仿真波形图上发现两个寄存器地址一直为空，与预期得到的波形图不一致。<br>**解决方法**：仔细检查了每一段代码，发现在顶层模块 topModule 的设计过程中误删了wire [3:0] control_signal 这一 ALU 控制信号，导致 CPU 没有正确地运行计算，补写后得到了正确的仿真结果。
   
5. **问题描述**：仿真测试时发现有些指令的输出与预期不一致，找不到代码的问题在哪里。<br>**解决方法**：通过搜索发现 Vivado 可以在终端打印一些调试信息，把寄存器里的值在每一步完成后打印出来。通过比对CPU中代码的执行和对汇编语言的分析发现了问题在于控制单元control模块中存在笔误。

6. **问题描述**：原有的第一条指令 lui x5 0x10010 在运行中会使运行到指令 sw x9, 0(x5) 时 x5 超出内存，影响仿真结果。 <br> **解决方法**：后续根据老师在微信群内发布的修改，将首条指令修改为 lui x5 0x00000 后整个代码段均可有正确的输出。

### **2. 实验心得**
- 通过本次32位RISC-V单周期CPU的设计实验，从最初的Verilog语言学习到最终完成整个CPU的设计与仿真，我对计算机体系结构有了更深入和系统的理解，收获很大。实验过程中，我首先通过课堂学习、上网搜索资料、查阅RISC-V指令集架构手册等方式，学习了单周期CPU的工作原理。通过分析每条指令的执行流程，我理解了取指、译码、执行、访存和写回五个阶段如何在单周期CPU中工作，对数据通路和控制信号的设计有了直观认识。
- 在模块设计与实现阶段，由于未学习过相关计算机系统基础课程缺乏实践经验，我对各功能模块和输入输出接口设计、指令结构等都不熟悉。通过阅读教材和参考网上的课程及项目，我逐步掌握了寄存器堆、ALU、控制单元等核心模块的设计方法。
- 调试过程仿真波形出现异常时，我尝试了分段测试定位问题。在解决仿真测试中信号缺失的问题时，我检查了指令译码到ALU运算的数据通路，发现了顶层模块的连线错误。这个过程也锻炼了我查阅资料、编写代码并debug的能力。
- 本次实验还让我理解了计算机硬件相关的具体工程是如何设计运作的。汇编指令到机器码的转换、功能模块到整体系统的集成，我都初次接触并通过网上资料、视频和 AI 工具逐步理解和运用。
- 从初步接触Verilog语言和计算机系统基础知识，到逐步写出ALU和功能完整的单周期CPU设计等项目，完成实验的全部要求，这个过程为我后续学习和编写更复杂的计算机系统打下了坚实基础。最后，非常感谢老师、助教和同学们在我完成这个项目期间给予我的各种指导和帮助！

## **七、附录（文件清单）**
<img src="image-25.png"  width="50%" height="auto">
